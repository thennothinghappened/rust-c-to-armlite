use std::fmt::Display;

use crate::lexer::Token;

#[derive(Debug, Clone, Copy, PartialEq)]
pub(crate) enum TokenKind {
    Semicolon,
    OpenParen,
    CloseParen,
    OpenCurly,
    CloseCurly,
    OpenSquare,
    CloseSquare,
    OpenAttributeList,
    CloseAttributeList,
    NamespaceAccessor,
    Ampersand,
    BooleanAnd,
    BitwiseOr,
    BooleanOr,
    Comma,
    Star,
    Assign,
    PlusAssign,
    MinusAssign,
    Plus,
    PlusPlus,
    Minus,
    MinusMinus,
    Divide,
    BooleanEqual,
    BooleanNotEqual,
    BooleanNot,
    LessThan,
    GreaterThan,
    If,
    Else,
    While,
    For,
    Return,
    Break,
    Continue,
    Struct,
    Union,
    TypeDef,
    Enum,
    Const,
    Extern,
    Signed,
    Asm,
    NullPtr,
    Unsigned,
    Short,
    Bool,
    Int,
    Long,
    Char,
    Float,
    Double,
    Void,
    SizeOf,
    QuestionMark,
    Colon,
    StringLiteral(IdentId),
    IntLiteral(i32),
    Ident(IdentId),
    Unknown(char),
    UnknownPreprocessorDirective(IdentId),
    ErrorPreprocessorDirective(IdentId),
    IncludeFileNotFound(IdentId),
    Eof,

    /// Not a real source-code token! This will never be seen by the parser. The lexer uses this
    /// to specify that some other thing has happened (e.g. macro expansion, or a comment), which
    /// the parser doesn't need to know about.
    DiscardMarker,
}

pub(crate) type IdentId = usize;

impl Display for TokenKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                TokenKind::Semicolon => ";",
                TokenKind::OpenParen => "(",
                TokenKind::CloseParen => ")",
                TokenKind::OpenCurly => "{",
                TokenKind::CloseCurly => "}",
                TokenKind::OpenSquare => "[",
                TokenKind::CloseSquare => "]",
                TokenKind::NamespaceAccessor => "::",
                TokenKind::OpenAttributeList => "[[",
                TokenKind::CloseAttributeList => "]]",
                TokenKind::Ampersand => "&",
                TokenKind::BooleanAnd => "&&",
                TokenKind::BooleanOr => "||",
                TokenKind::BitwiseOr => "|",
                TokenKind::Star => "*",
                TokenKind::Comma => ",",
                TokenKind::Assign => "=",
                TokenKind::PlusAssign => "+=",
                TokenKind::MinusAssign => "-=",
                TokenKind::Plus => "+",
                TokenKind::PlusPlus => "++",
                TokenKind::Minus => "-",
                TokenKind::MinusMinus => "--",
                TokenKind::Divide => "/",
                TokenKind::BooleanEqual => "==",
                TokenKind::BooleanNotEqual => "!=",
                TokenKind::BooleanNot => "!",
                TokenKind::LessThan => "<",
                TokenKind::GreaterThan => ">",
                TokenKind::If => "if",
                TokenKind::Else => "else",
                TokenKind::While => "while",
                TokenKind::For => "for",
                TokenKind::Return => "return",
                TokenKind::Break => "break",
                TokenKind::Continue => "continue",
                TokenKind::Struct => "struct",
                TokenKind::Union => "union",
                TokenKind::TypeDef => "typedef",
                TokenKind::Enum => "enum",
                TokenKind::Unsigned => "unsigned",
                TokenKind::Signed => "signed",
                TokenKind::Bool => "bool",
                TokenKind::Int => "int",
                TokenKind::Long => "long",
                TokenKind::Short => "short",
                TokenKind::Char => "char",
                TokenKind::Float => "float",
                TokenKind::Double => "double",
                TokenKind::Void => "void",
                TokenKind::NullPtr => "nullptr",
                TokenKind::SizeOf => "sizeof",
                TokenKind::Const => "const",
                TokenKind::Extern => "extern",
                TokenKind::QuestionMark => "?",
                TokenKind::Colon => ":",
                TokenKind::StringLiteral(_) => "string",
                TokenKind::Ident(_) => "identifier",
                TokenKind::IntLiteral(int) => return write!(f, "{int}"),
                TokenKind::Unknown(char) => return write!(f, "Unknown({char})"),
                TokenKind::IncludeFileNotFound(id) =>
                    return write!(f, "<<Failed include for source with identifier ID {id:?}>>"),
                TokenKind::UnknownPreprocessorDirective(_) =>
                    return write!(f, "<<Unknown Preprocessor Directive>>"),
                TokenKind::ErrorPreprocessorDirective(_) =>
                    return write!(f, "<<Preprocessor-thrown error>>"),
                TokenKind::DiscardMarker => "<<Internal Discard Marker>>",
                TokenKind::Eof => "<<End Of File>>",
                TokenKind::Asm => "__asm__",
            }
        )
    }
}
